# Daily Study
## Daily Plan
#todo
- [x] 写博客
- [ ] 
## Kafka深度学习
#暑期实习 
### Kafka是如何实现高吞吐率的
Kafka的设计是把所有的消息都写入速度低容量大的硬盘，以此来换取更强的存储能力，但实际上，使用硬盘并没有带来过多的性能损失。`kafka`主要使用了以下几个方式实现了超高的吞吐率：
- 顺序读写：`partition`顺序读写，充分利用磁盘特性
- 零拷贝
- 文件分段
- 批量发送
- 数据压缩

其中针对零拷贝的原理具体如下：
- 使用了`mmap`映射。`Producer`生产的数据持久化到`broker`，采用`mmap`文件映射，实现顺序的快速写入。`mmap`映射简单描述其作用就是：将磁盘文件映射到内存, 用户通过修改内存就能修改磁盘文件。它的工作原理是直接利用操作系统的`Page`来实现文件到物理内存的直接映射。完成映射之后你对物理内存的操作会被同步到硬盘上（操作系统在适当的时候）因此`mmap`有一个缺陷是不可靠，因为`mmap`中的数据通常不是真正的立马就写到硬盘中。
- 使用了零拷贝 `sendfile(in,out)`。`Customer`从`broker`读取数据，采用`sendfile`，将磁盘文件读到`OS`内核缓冲区后，直接转到`socket buffer`进行网络发送。`sendfile`的原理是数据直接在内核完成输入和输出，不需要拷贝到用户空间再写出去。例如`linux`中磁盘数据通过 `DMA` 拷贝到内核态 `Buffer` 后，直接通过 `DMA` 拷贝到 `NIC Buffer(socket buffer)`，无需 `CPU` 拷贝。

## Mysql索引相关
### Mysql索引优化/失效
原来问索引优化可以类比到索引失效的场景~

基本规则：查询的条件字段尽量用索引字段

- `and/or`条件相连：`and`条件相连，有一列有索引就会命中索引，加快查询速度；`or`条件相连，所有列都有索引才能命中索引，加快查询速度；
- `like`语句的前导模糊查询不能使用索引：`select * from doc where title like '%XX '；`
- `union、in、or` 都能够命中索引，建议使用 `in`
- 负向条件查询不能使用索引：负向条件有：`!=、<>、not in、not exists、not like` 等。可以优化成 `in` 查询
- 联合索引最左前缀原则
- 不能使用索引中范围条件右边的列（范围列可以用到索引），范围列之后列的索引全失效：索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引，范围条件有：`<、<=、>、>=、between`等
- 不要在索引列上面做任何操作（计算、函数），否则会导致索引失效而转向全表扫描
- 强制类型转换会全表扫描：字符串类型不加单引号会导致索引失效，因为mysql会自己做类型转换,相当于在索引列上进行了操作，例如 `select * from user where phone=13800001234`，应该 `phone = '13...'`
- 更新十分频繁、数据区分度不高的列不宜建立索引
-  利用覆盖索引来进行查询操作，避免回表，减少`select *` 的使用
- 索引不会包含有`NULL`值的列:只要列中包含有`NULL`值都将不会被包含在索引中，复合索引中只要有一列含有`NULL`值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时，尽量使用`not null` 约束以及默认值
- `is null, is not null`无法使用索引:
- 如果有`order by`、`group by`的场景，请注意利用索引的有序性：`order by` 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现`file_sort` 的情况，影响查询性能。例如对于语句 `where a=? and b=? order by c`，可以建立联合索引`(a,b,c)`。
- 使用短索引（前缀索引）：对列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个`CHAR(255)`的列，如果该列在前10个或20个字符内，可以做到既使得前缀索引的区分度接近全列索引，那么就不要对整个列进行索引。因为短索引不仅可以提高查询速度而且可以节省磁盘空间和`I/O`操作，减少索引文件的维护开销。可以使用`count(distinct leftIndex(列名, 索引长度))/count(*)` 来计算前缀索引的区分度。但缺点是不能用于 `ORDER BY` 和 `GROUP BY` 操作，也不能用于覆盖索引
- 利用延迟关联或者子查询优化超多分页场景：这里说的是具体查询很多页中的某一页，可以利用`offset`，先快速定位需要获取的`id`段，然后再关联：`select a.* from 表1 a,(select id from 表1 where 条件 limit100000,20 ) b where a.id=b.id；`
- 如果明确知道只有一条结果返回，`limit 1` 能够提高效率
- 单表索引建议控制在5个以内
- `SQL` 性能优化 `explain` 中的 `type`：至少要达到 `range` 级别，要求是 `ref` 级别，如果可以是 `consts` 最好
	- `consts`：单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。
	- `ref`：使用普通的索引（`Normal Index`）。
	- `range`：对索引进行范围检索。
	- 当 `type=index` 时，索引物理文件全扫，速度非常慢。
- 业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引

### Mysql索引用/不用
使用索引：
- 主键自动建立唯一索引。 
- 经常作为查询条件在WHERE或者ORDER BY 语句中出现的列要建立索引。 
- 查询中与其他表关联的字段，外键关系建立索引。 
- 经常用于聚合函数的列要建立索引，如min()，max()等的聚合函数。

不用索引：
- 经常增删改的列不要建立索引。 
- 有大量重复的列不建立索引。 
- 表记录太少不要建立索引，因为数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果 。


