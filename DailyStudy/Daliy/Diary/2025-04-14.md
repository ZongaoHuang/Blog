# Daily Plan
#todo
- [x] go.time
- [ ] 
# Daily Study
## 空结构体的应用
#go
参考链接：[Go 空结构体：零内存的魔力-阿里云开发者社区](https://developer.aliyun.com/article/1230762)
两种定义方式：`var e struct{}`, `type EmptyStruct struct{} var EmptyStruct`
特点：
- 零内存占用
- 地址相同
- 无状态
主要有三个应用场景：
	- 实现set集合：基于map[T]struct{}
	- 用于通道信号：使用一个空结构体来通知goroutine停止工作，主要是用 `close(quit)`
	- 作为方法接收器

## defer的使用
#go 
defer的几个核心点：
1. 延迟执行：在函数结束时执行，包括正常返回或遭遇 panic。
2. 栈式执行顺序：后定义的 `defer` 先执行（LIFO）。
3. 参数预计算：`defer` 语句定义时即计算并固定参数值。
4. 值传递原则：`defer` 拷贝参数，使用定义时的值。
5. 环境变量捕获：在 `defer` 中可以跟一个闭包，闭包可以捕获环境变量，当然这包括具名返回值。
具体应用：
- 文件关闭，锁释放，资源回收，数据库事务回滚
- 错误处理，defer和recover，来防止程序因为panic而终止，做一些性能监控

## snowflake
#go 

详解：[深度思考：雪花算法snowflake分布式id生成原理详解-阿里云开发者社区](https://developer.aliyun.com/article/1471164)
### 定义
Snowflake算法的原理相对直观，它负责生成一个64位（long型）的全局唯一ID，这个ID的构成包括：1位无用的符号位、41位的时间戳、10位的机器ID以及12位的序列号，除了固定的1位符号位之外，其余的三个部分都可以根据实际需求进行调整：
**1、41位时间戳**：这部分能够表示的时间跨度为`（1L<<41）/(1000L*3600*24*365)`，即大约69年。
**2、10位机器ID**：可以唯一标识最多1024台机器，如果需要对互联网数据中心（IDC）进行划分，可以将这10位拆分为两部分，例如各5位，这样，系统就能够表示最多32个IDC，且每个IDC下可以容纳32台机器。
**3、12位自增序列号**：用于在同一毫秒内生成多个ID，最多可以表示2^12个不同的ID，因此，理论上，Snowflake算法能够达到的每秒查询率（QPS）约为`409.6`万。
![[attachments/1744619690874_d.png]]
### 优缺点
优点：
- 毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。
- 可以不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也非常高。
- 可以根据自身业务特性分配bit位，非常灵活。

缺点：
- 强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务处于不可用状态。
解决方法：

# Daily Problem